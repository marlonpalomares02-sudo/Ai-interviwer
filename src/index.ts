import { BrowserWindow, app, ipcMain, desktopCapturer, session, screen } from 'electron';
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
import Prism from 'prismjs';
import OpenAI from 'openai';
import axios from 'axios';
import FormData from 'form-data';
import fs from 'fs';
import path from 'path';
import { Buffer } from 'buffer';
import { createClient, LiveTranscriptionEvents } from '@deepgram/sdk';

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
import electronSquirrelStartup from 'electron-squirrel-startup';

if (electronSquirrelStartup) {
  app.quit();
}

let mainWindow: BrowserWindow;
let pipWindow: BrowserWindow | null = null;

const createWindow = (): void => {
  mainWindow = new BrowserWindow({
    height: 1000,
    width: 1300,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
      nodeIntegration: false,
      webSecurity: false,
    },
  });

  // Prevent this window from being captured by screen recorders and shares
  // mainWindow.setContentProtection(true); // Disabled as per user request

  mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': [
          "default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval' blob:; connect-src 'self' https://api.openai.com wss://api.deepgram.com https://api.deepseek.com https://generativelanguage.googleapis.com;",
        ],
      },
    });
  });

  mainWindow.webContents.session.setPermissionRequestHandler(
    (webContents, permission, callback) => {
      if (permission === 'media') {
        callback(true);
      } else {
        callback(false);
      }
    }
  );

  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY + '#/main_window');
  //  mainWindow.webContents.openDevTools();

  mainWindow.webContents.on('did-finish-load', () => {
    mainWindow.webContents.executeJavaScript(`
      console.log('Applied CSP:', document.querySelector('meta[http-equiv="Content-Security-Policy"]')?.getAttribute('content'));
    `);
  });
};

const createPiPWindow = (): BrowserWindow => {
  pipWindow = new BrowserWindow({
    width: 400,
    height: 300,
    frame: false,
    alwaysOnTop: true,
    skipTaskbar: true,
    resizable: true,
    movable: true,
    minimizable: false,
    maximizable: false,
    closable: true,
    transparent: true,
    hasShadow: false,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
      nodeIntegration: false,
      webSecurity: false,
    },
    titleBarStyle: 'customButtonsOnHover',
    roundedCorners: true,
  });

  pipWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY + '#/pip_window');

  // Make the window draggable
  pipWindow.webContents.on('did-finish-load', () => {
    pipWindow?.webContents.executeJavaScript(`
      document.addEventListener('mousedown', (e) => {
        if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'INPUT') {
          window.electronAPI.ipcRenderer.invoke('start-drag', {x: e.screenX, y: e.screenY});
        }
      });
    `);
  });

  pipWindow.on('closed', () => {
    pipWindow = null;
  });

  return pipWindow;
};

ipcMain.handle('hide-main-window', () => {
  if (mainWindow) {
    mainWindow.hide();
  }
});

ipcMain.handle('show-main-window', () => {
  if (mainWindow) {
    mainWindow.show();
  }
});

ipcMain.handle('toggle-pip-window', () => {
  if (pipWindow && !pipWindow.isDestroyed()) {
    pipWindow.close();
    pipWindow = null;
    return false;
  } else {
    pipWindow = createPiPWindow();
    return true;
  }
});

ipcMain.handle('resize-pip-window', (_event, expanded: boolean) => {
  if (pipWindow && !pipWindow.isDestroyed()) {
    const bounds = pipWindow.getBounds();
    const target = expanded ? { width: 680, height: 420 } : { width: 400, height: 300 };
    pipWindow.setBounds({ x: bounds.x, y: bounds.y, width: target.width, height: target.height });
  }
});

ipcMain.handle('minimize-pip-window', (_event, minimized: boolean) => {
  if (pipWindow && !pipWindow.isDestroyed()) {
    if (minimized) {
      pipWindow.setMinimumSize(300, 48);
      pipWindow.setSize(300, 48);
    } else {
      pipWindow.setMinimumSize(300, 200);
      pipWindow.setSize(400, 300);
    }
  }
});

ipcMain.handle('clear-pip-content', () => {
  if (pipWindow && !pipWindow.isDestroyed()) {
    pipWindow.webContents.send('clear-pip-content');
  }
});

ipcMain.handle('update-pip-content', (event, content: string) => {
  if (pipWindow && !pipWindow.isDestroyed()) {
    pipWindow.webContents.send('update-content', content);
  }
});

ipcMain.handle('start-drag', (event, { x, y }) => {
  if (pipWindow && !pipWindow.isDestroyed()) {
    const currentPos = pipWindow.getPosition();
    const offset = { x: x - currentPos[0], y: y - currentPos[1] };

    const handleMouseMove = (e: any) => {
      pipWindow?.setPosition(e.screenX - offset.x, e.screenY - offset.y);
    };

    const handleMouseUp = () => {
      // Remove listeners when mouse is released
    };

    // Use setTimeout to simulate mouse move tracking
    const moveInterval = setInterval(() => {
      const point = screen.getCursorScreenPoint();
      pipWindow?.setPosition(point.x - offset.x, point.y - offset.y);
    }, 16); // ~60fps

    const cleanup = () => {
      clearInterval(moveInterval);
      handleMouseUp();
    };

    // Stop dragging after 5 seconds or when mouse is released (whichever comes first)
    setTimeout(cleanup, 5000);

    // Listen for mouse up event (simplified approach)
    setTimeout(() => {
      cleanup();
    }, 100); // Quick cleanup check
  }
});

ipcMain.handle('start-resize', (event, { x, y, direction }) => {
  if (pipWindow && !pipWindow.isDestroyed()) {
    const currentBounds = pipWindow.getBounds();
    const startX = x;
    const startY = y;
    const startWidth = currentBounds.width;
    const startHeight = currentBounds.height;

    const handleMouseMove = () => {
      const point = screen.getCursorScreenPoint();
      const deltaX = point.x - startX;
      const deltaY = point.y - startY;

      let newWidth = startWidth;
      let newHeight = startHeight;

      if (direction.includes('right')) {
        newWidth = Math.max(300, startWidth + deltaX);
      }
      if (direction.includes('bottom')) {
        newHeight = Math.max(200, startHeight + deltaY);
      }

      pipWindow?.setBounds({
        width: newWidth,
        height: newHeight,
      });
    };

    // Use setInterval to track mouse movement for resizing
    const resizeInterval = setInterval(handleMouseMove, 16); // ~60fps

    const cleanup = () => {
      clearInterval(resizeInterval);
    };

    // Stop resizing after 5 seconds or when mouse is released (whichever comes first)
    setTimeout(cleanup, 5000);

    // Quick cleanup check
    setTimeout(() => {
      cleanup();
    }, 100);
  }
});

ipcMain.handle('save-temp-audio-file', async (event, audioBuffer: ArrayBuffer) => {
  try {
    const tempFilePath = path.join(app.getPath('temp'), `temp_audio_${Date.now()}.wav`);
    fs.writeFileSync(tempFilePath, new Uint8Array(audioBuffer));
    return tempFilePath;
  } catch (error) {
    throw error;
  }
});

ipcMain.handle('transcribe-audio-file', async (event, filePath: string, config) => {
  try {
    const formData = new FormData();
    formData.append('file', fs.createReadStream(filePath), 'audio.wav');
    formData.append('model', 'whisper-1');

    if (config.primaryLanguage && config.primaryLanguage !== 'auto') {
      formData.append('language', config.primaryLanguage);
    }
    if (config.secondaryLanguage) {
      formData.append(
        'prompt',
        `This audio may contain ${config.primaryLanguage} and ${config.secondaryLanguage}.`
      );
    }

    const baseUrl = normalizeApiBaseUrl(config.api_base);
    const apiUrl = `${baseUrl}/audio/transcriptions`;
    const response = await axios.post(apiUrl, formData, {
      headers: {
        ...formData.getHeaders(),
        Authorization: `Bearer ${config.openai_key}`,
      },
      maxContentLength: Infinity,
      maxBodyLength: Infinity,
    });

    return response.data;
  } catch (error) {
    throw error;
  } finally {
    fs.unlinkSync(filePath);
  }
});

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the
// dock icon is clicked and there are no other windows open.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

import ElectronStore from 'electron-store';

interface StoreSchema {
  config: Record<string, any>;
  promptTemplates?: { name: string; prompt: string }[];
}

type TypedElectronStore = ElectronStore<StoreSchema> & {
  get: <K extends keyof StoreSchema>(key: K) => StoreSchema[K];
  set: <K extends keyof StoreSchema>(key: K, value: StoreSchema[K]) => void;
  clear: () => void;
};

const store = new ElectronStore<StoreSchema>() as TypedElectronStore;

ipcMain.handle('get-config', () => {
  return store.get('config');
});

ipcMain.handle('set-config', (event, config) => {
  store.set('config', config);
});

ipcMain.handle('get-prompt-templates', () => {
  return store.get('promptTemplates') || [];
});

ipcMain.handle('set-prompt-templates', (event, templates) => {
  store.set('promptTemplates', templates);
});

ipcMain.handle('parsePDF', async (event, pdfBuffer) => {
  try {
    const pdf = require('pdf-parse');
    const data = await pdf(Buffer.from(pdfBuffer), {
      max: 0,
    });
    return { text: data.text };
  } catch (error) {
    return { error: 'Failed to parse PDF: ' + error.message };
  }
});

ipcMain.handle('process-image', async (event, imageData) => {
  try {
    const sharp = require('sharp');
    let image;
    if (imageData.startsWith('data:image')) {
      const base64Data = imageData.split(',')[1];
      const imageBuffer = Buffer.from(base64Data, 'base64');
      image = sharp(imageBuffer);
    } else {
      throw new Error('Invalid image input: expected Base64 encoded image data');
    }
    const metadata = await image.metadata();
    return `Image size: ${metadata.width}x${metadata.height}, Format: ${metadata.format}`;
  } catch (error) {
    return { error: 'Failed to process image: ' + error.message };
  }
});

ipcMain.handle('highlightCode', async (event, code, language) => {
  return Prism.highlight(code, Prism.languages[language], language);
});

app.on('before-quit', () => {
  const config = store.get('config') || {};
  const apiInfo = {
    openai_key: config.openai_key || '',
    api_base: config.api_base || '',
    gpt_model: config.gpt_model || '',
    api_call_method: config.api_call_method || 'direct',
    primaryLanguage: config.primaryLanguage || 'en',
    deepgram_api_key: config.deepgram_api_key || '',
    deepseek_api_key: config.deepseek_api_key || '',
    gemini_api_key: config.gemini_api_key || '',
    deepseek_model: config.deepseek_model || 'deepseek-chat',
    deepseek_api_base: config.deepseek_api_base || '',
    selected_provider: config.selected_provider || 'deepseek',
    ai_system_prompt: config.ai_system_prompt || '',
    openai_api_base: config.openai_api_base || '',
  };
  store.clear();
  store.set('config', apiInfo);
});

ipcMain.handle('get-system-audio-stream', async () => {
  try {
    const sources = await desktopCapturer.getSources({
      types: ['window', 'screen'],
      fetchWindowIcons: false,
    });
    const audioSources = sources.filter(
      (source) =>
        source.name.toLowerCase().includes('sound') || source.name.toLowerCase().includes('audio')
    );
    return audioSources.map((source) => source.id);
  } catch (error) {
    throw error;
  }
});

app.on('ready', () => {
  session.defaultSession.setDisplayMediaRequestHandler(
    (request, callback) => {
      desktopCapturer.getSources({ types: ['screen'] }).then((sources) => {
        callback({ video: sources[0], audio: 'loopback' });
      });
    },
    { useSystemPicker: true }
  );

  ipcMain.handle('transcribe-audio', async (event, audioBuffer: ArrayBuffer, config) => {
    try {
      const tempFilePath = path.join(app.getPath('temp'), `temp_audio_${Date.now()}.wav`);
      fs.writeFileSync(tempFilePath, new Uint8Array(audioBuffer));

      const formData = new FormData();
      formData.append('file', fs.createReadStream(tempFilePath), {
        filename: 'audio.wav',
        contentType: 'audio/wav',
      });
      formData.append('model', 'whisper-1');

      if (config.primaryLanguage && config.primaryLanguage !== 'auto') {
        formData.append('language', config.primaryLanguage);
      }
      if (config.secondaryLanguage) {
        formData.append(
          'prompt',
          `This audio may contain ${config.primaryLanguage} and ${config.secondaryLanguage}.`
        );
      }

      const baseUrl = normalizeApiBaseUrl(config.api_base);
      const apiUrl = `${baseUrl}/audio/transcriptions`;
      const response = await axios.post(apiUrl, formData, {
        headers: {
          ...formData.getHeaders(),
          Authorization: `Bearer ${config.openai_key}`,
        },
        maxContentLength: Infinity,
        maxBodyLength: Infinity,
      });

      fs.unlinkSync(tempFilePath);

      return response.data;
    } catch (error) {
      throw error;
    }
  });
});

ipcMain.handle('test-api-config', async (event, config) => {
  try {
    const selectedProvider = config.selected_provider || 'deepseek';
    console.log('Testing API config for provider:', selectedProvider);

    if (selectedProvider === 'gemini') {
      if (!config.gemini_api_key) {
        return { success: false, error: 'Gemini API Key is missing' };
      }

      const { GoogleGenerativeAI } = require('@google/generative-ai');
      const genAI = new GoogleGenerativeAI(config.gemini_api_key);
      const model = genAI.getGenerativeModel({ model: config.gemini_model || 'gemini-1.5-flash' });

      const result = await model.generateContent('Hello, this is a test.');
      const response = await result.response;
      const text = response.text();

      if (text) {
        return { success: true };
      } else {
        return { success: false, error: 'Unexpected Gemini API response structure' };
      }
    } else if (selectedProvider === 'openai') {
      if (!config.openai_key) {
        return { success: false, error: 'OpenAI API Key is missing' };
      }

      const openai = new OpenAI({
        apiKey: config.openai_key,
        baseURL: normalizeApiBaseUrl(config.api_base),
      });

      const response = await openai.chat.completions.create({
        model: config.gpt_model || 'gpt-3.5-turbo',
        messages: [{ role: 'user', content: 'Hello, this is a test.' }],
      });

      if (response.choices && response.choices[0] && response.choices[0].message) {
        return { success: true };
      } else {
        return { success: false, error: 'Unexpected OpenAI API response structure' };
      }
    } else {
      // DeepSeek test
      console.log('Testing API config with:', {
        api_base: config.deepseek_api_base,
        model: config.deepseek_model,
        key_length: config.deepseek_api_key ? config.deepseek_api_key.length : 0,
      });

      // Check if DeepSeek API key is provided
      if (!config.deepseek_api_key || config.deepseek_api_key === 'placeholder_deepseek_api_key') {
        return { success: false, error: 'DeepSeek API key is missing or invalid. Please check your settings.' };
      }

      const baseUrl = normalizeApiBaseUrl(config.deepseek_api_base, 'https://api.deepseek.com/v1');
      console.log('Normalized base URL:', baseUrl);

      const axiosInstance = axios.create({
        baseURL: baseUrl,
        headers: {
          Authorization: `Bearer ${config.deepseek_api_key}`,
          'Content-Type': 'application/json',
        },
      });

      const response = await axiosInstance.post('/chat/completions', {
        model: config.deepseek_model || 'deepseek-chat',
        messages: [{ role: 'user', content: 'Hello, this is a test.' }],
      });

      if (response.data.choices && response.data.choices[0] && response.data.choices[0].message) {
        return { success: true };
      } else {
        return { success: false, error: 'Unexpected API response structure' };
      }
    }
  } catch (error) {
    console.error('API test error:', error);
    if (axios.isAxiosError(error)) {
      if (error.response) {
        console.error('API test failed with response:', error.response.status, error.response.data);
        return {
          success: false,
          error: `Server responded with error: ${error.response.status} ${error.response.statusText}. ${error.response.data?.error?.message || ''}`,
        };
      } else if (error.request) {
        console.error('API test failed - no response:', error.request);
        return {
          success: false,
          error:
            'No response received from server. Please check your network connection and API base URL.',
        };
      } else {
        console.error('API test failed - request setup error:', error.message);
        return {
          success: false,
          error: `Error setting up the request: ${error.message}`,
        };
      }
    }
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error occurred',
    };
  }
});

ipcMain.handle('callOpenAI', async (event, { config, messages, signal }) => {
  try {
    const openai = new OpenAI({
      apiKey: config.openai_key,
      baseURL: normalizeApiBaseUrl(config.api_base),
    });

    const abortController = new AbortController();
    if (signal) {
      signal.addEventListener('abort', () => abortController.abort());
    }

    const response = await openai.chat.completions.create(
      {
        model: config.gpt_model || 'gpt-3.5-turbo',
        messages: messages,
      },
      { signal: abortController.signal }
    );

    if (!response.choices || !response.choices[0] || !response.choices[0].message) {
      throw new Error('Unexpected API response structure');
    }
    return { content: response.choices[0].message.content };
  } catch (error) {
    if (error.name === 'AbortError') {
      return { error: 'AbortError' };
    }
    return { error: error.message || 'Unknown error occurred' };
  }
});

ipcMain.handle('callDeepSeek', async (event, { config, messages, signal }) => {
  try {
    const selectedProvider = config.selected_provider || 'deepseek';
    
    if (selectedProvider === 'gemini') {
      if (!config.gemini_api_key) {
        throw new Error('Gemini API Key is missing');
      }

      const { GoogleGenerativeAI } = require('@google/generative-ai');
      const genAI = new GoogleGenerativeAI(config.gemini_api_key);
      const model = genAI.getGenerativeModel({ 
        model: config.gemini_model || 'gemini-1.5-flash',
        systemInstruction: messages.find((m: any) => m.role === 'system')?.content || ''
      });

      // Convert messages to Gemini format
      // Filter out system message as it's handled above
      // Combine consecutive user/assistant messages if needed, but Gemini handles history well
      const history = messages
        .filter((m: any) => m.role !== 'system')
        .slice(0, -1) // All except last message
        .map((m: any) => ({
          role: m.role === 'assistant' ? 'model' : 'user',
          parts: [{ text: m.content }],
        }));

      const chat = model.startChat({
        history: history,
      });

      const lastMessage = messages[messages.length - 1];
      const result = await chat.sendMessage(lastMessage.content);
      const response = await result.response;
      const text = response.text();

      return { content: text };
    } else if (selectedProvider === 'openai') {
      if (!config.openai_key) {
        throw new Error('OpenAI API Key is missing');
      }

      const openai = new OpenAI({
        apiKey: config.openai_key,
        baseURL: normalizeApiBaseUrl(config.api_base),
      });

      const abortController = new AbortController();
      if (signal) {
        signal.addEventListener('abort', () => abortController.abort());
      }

      const response = await openai.chat.completions.create({
        model: config.gpt_model || 'gpt-3.5-turbo',
        messages: messages,
      }, { signal: abortController.signal });

      if (!response.choices || !response.choices[0] || !response.choices[0].message) {
        throw new Error('Unexpected OpenAI API response structure');
      }
      return { content: response.choices[0].message.content };
    } else {
      // Existing DeepSeek logic
      const deepseekApi = axios.create({
        baseURL: normalizeApiBaseUrl(config.deepseek_api_base, 'https://api.deepseek.com/v1'),
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${config.deepseek_api_key}`,
        },
        maxBodyLength: Infinity,
        maxContentLength: Infinity,
        timeout: 60000, // 60 seconds timeout
      });

      const response = await deepseekApi.post('/chat/completions', {
        model: config.deepseek_model || 'deepseek-chat',
        messages: messages,
      });

      if (!response.data.choices || !response.data.choices[0] || !response.data.choices[0].message) {
        throw new Error('Unexpected API response structure from DeepSeek');
      }
      return { content: response.data.choices[0].message.content };
    }
  } catch (error) {
    console.error('DeepSeek AI Call Error:', error);
    
    if (axios.isAxiosError(error)) {
      if (error.code === 'ECONNABORTED') {
         return { error: 'Request timed out. Please try with shorter content.' };
      }
      if (error.response) {
        const status = error.response.status;
        const errorData = error.response.data;
        
        let errorMessage = `API Error ${status}: `;
        
        switch (status) {
          case 401:
            errorMessage += 'Authentication failed - Invalid API key';
            break;
          case 403:
            errorMessage += 'Access forbidden - Check API permissions';
            break;
          case 404:
            errorMessage += 'API endpoint not found - Check API configuration';
            break;
          case 429:
            errorMessage += 'Rate limit exceeded - Please try again later';
            break;
          case 500:
            errorMessage += 'Server error - DeepSeek service may be down';
            break;
          case 503:
            errorMessage += 'Service unavailable - Please try again later';
            break;
          default:
            errorMessage += errorData?.error?.message || errorData?.error || 'Unknown API error';
        }
        
        return { error: errorMessage };
      }
      
      if (error.request) {
        return { error: 'Network Error: Unable to reach DeepSeek API. Please check your internet connection.' };
      }
      
      return { error: `Network Error: ${error.message}` };
    }
    
    if (error instanceof Error) {
      if (error.message.includes('API key')) {
        return { error: 'DeepSeek API key is missing or invalid' };
      }
      return { error: error.message };
    }
    
    return { error: 'Unknown error occurred with DeepSeek API' };
  }
});

ipcMain.handle('get-desktop-sources', async () => {
  try {
    const sources = await desktopCapturer.getSources({
      types: ['window', 'screen'],
      fetchWindowIcons: true,
      thumbnailSize: { width: 320, height: 200 },
    });
    return sources.map((source) => ({
      id: source.id,
      name: source.name,
      type: source.id.startsWith('screen:') ? 'screen' : 'window',
      thumbnail: source.thumbnail.toDataURL(),
      appIcon: source.appIcon ? source.appIcon.toDataURL() : null,
    }));
  } catch (error) {
    return [];
  }
});

function normalizeApiBaseUrl(
  url: string,
  defaultUrl: string = 'https://api.openai.com/v1'
): string {
  if (!url) return defaultUrl;
  url = url.trim();
  if (!url.startsWith('http://') && !url.startsWith('https://')) {
    url = 'https://' + url;
  }
  if (!url.endsWith('/v1')) {
    url = url.endsWith('/') ? url + 'v1' : url + '/v1';
  }
  return url;
}

let deepgramConnection: any = null;
let deepgramRetryCount = 0;
const MAX_DEEPGRAM_RETRIES = 3;

ipcMain.handle('start-deepgram', async (event, config) => {
  try {
    if (!config.deepgram_key) {
      throw new Error('Deepgram API key is required');
    }

    const deepgram = createClient(config.deepgram_key);

    // Enhanced connection configuration with better error handling for screenshare
    deepgramConnection = deepgram.listen.live({
      punctuate: true,
      interim_results: true,
      model: 'nova-2-general',
      language: config.primaryLanguage || 'en',
      encoding: 'linear16',
      sample_rate: 16000,
      endpointing: 1500,
      vad_events: true,
      // Add enhanced settings for better screenshare transcription
      smart_format: true,
      filler_words: true,
      profanity_filter: false,
      // Better handling of audio with gaps (common in screenshare)
      interim_results_timeout: 3000,
    });

    // Connection event handlers with enhanced logging
    deepgramConnection.addListener(LiveTranscriptionEvents.Open, () => {
      console.log('Deepgram connection opened successfully');
      deepgramRetryCount = 0; // Reset retry count on successful connection
      event.sender.send('deepgram-status', { status: 'open' });
    });

    deepgramConnection.addListener(LiveTranscriptionEvents.Close, () => {
      console.log('Deepgram connection closed');
      event.sender.send('deepgram-status', { status: 'closed' });
    });

    // Enhanced transcript handling with better error checking for screenshare
    deepgramConnection.addListener(LiveTranscriptionEvents.Transcript, (data: any) => {
      try {
        if (data && data.channel && data.channel.alternatives && data.channel.alternatives[0]) {
          const transcript = data.channel.alternatives[0].transcript?.trim();
          const confidence = data.channel.alternatives[0].confidence;
          
          // Enhanced logging for screenshare transcription
          if (transcript) {
            console.log(`Transcript received: "${transcript}" (final: ${data.is_final}, confidence: ${confidence})`);
          }
          
          event.sender.send('deepgram-transcript', {
            transcript,
            is_final: data.is_final || false,
            confidence: confidence,
          });
        } else {
          console.log('Transcript data received but no valid transcript content');
        }
      } catch (transcriptError) {
        console.error('Error processing transcript:', transcriptError);
      }
    });

    // Enhanced error handling with automatic recovery
    deepgramConnection.addListener(LiveTranscriptionEvents.Error, (err: any) => {
      console.error('Deepgram connection error:', err);

      // Enhanced error logging for debugging
      if (err && err.message) {
        console.error('Deepgram error details:', err.message);
      }
      if (err && err.code) {
        console.error('Deepgram error code:', err.code);
      }

      // Attempt automatic recovery for certain error types
      if (deepgramRetryCount < MAX_DEEPGRAM_RETRIES) {
        deepgramRetryCount++;
        console.log(
          `Attempting Deepgram reconnection (${deepgramRetryCount}/${MAX_DEEPGRAM_RETRIES})`
        );

        // Close current connection and attempt to restart
        if (deepgramConnection) {
          try {
            deepgramConnection.finish();
          } catch (finishError) {
            console.warn('Error finishing Deepgram connection:', finishError);
          }
          deepgramConnection = null;
        }

        // Send error with retry information
        event.sender.send('deepgram-error', {
          ...err,
          retryCount: deepgramRetryCount,
          maxRetries: MAX_DEEPGRAM_RETRIES,
        });
      } else {
        // Max retries reached, send final error
        event.sender.send('deepgram-error', {
          ...err,
          fatal: true,
          message: 'Max Deepgram retry attempts reached',
        });
      }
    });

    // Connection timeout with better error handling
    const connectionPromise = new Promise((resolve, reject) => {
      deepgramConnection.addListener(LiveTranscriptionEvents.Open, resolve);
      deepgramConnection.addListener(LiveTranscriptionEvents.Error, reject);
    });

    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Deepgram connection timeout')), 15000);
    });

    await Promise.race([connectionPromise, timeoutPromise]);

    console.log('Deepgram connection established successfully');
    return { success: true };
  } catch (error) {
    console.error('Failed to start Deepgram connection:', error);
    return { success: false, error: error.message };
  }
});

ipcMain.handle('send-audio-to-deepgram', async (event, audioData) => {
  if (deepgramConnection) {
    try {
      const buffer = Buffer.from(audioData);
      
      // Enhanced logging for audio data being sent
      const sampleCount = buffer.length / 2; // 16-bit samples
      const durationMs = (sampleCount / 16000) * 1000; // 16kHz sample rate
      
      // Log audio data periodically (every 5 seconds worth of audio)
      if (sampleCount >= 80000) { // 5 seconds at 16kHz
        console.log(`Sending audio to Deepgram: ${sampleCount} samples (${durationMs.toFixed(0)}ms)`);
      }
      
      deepgramConnection.send(buffer);
    } catch (error) {
      console.error('Failed to send data to Deepgram:', error);
      
      // Enhanced error handling - don't let one failed send kill the connection
      if (error instanceof Error) {
        console.error('Send error details:', error.message);
        
        // Only attempt reconnection for specific error types
        if (error.message.includes('closed') || error.message.includes('disconnected')) {
          console.log('Connection appears to be closed, will handle reconnection in error handler');
        }
      }
    }
  } else {
    console.warn('No Deepgram connection available to send audio data');
  }
});

ipcMain.handle('stop-deepgram', () => {
  if (deepgramConnection) {
    deepgramConnection.finish();
    deepgramConnection = null;
  }
});
